"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOperationToPatches;
exports.VALUE_TO_JSON_OPTS = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _blockTools = require("@sanity/block-tools");

var _slate = require("slate");

var _PatchEvent = require("../../../PatchEvent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VALUE_TO_JSON_OPTS = {
  preserveData: true,
  preserveKeys: true,
  preserveSelection: false,
  preserveHistory: false
};
exports.VALUE_TO_JSON_OPTS = VALUE_TO_JSON_OPTS;

function findSpanTargetPath(nodeInEditorValue, offset, editorValue, block) {
  if (nodeInEditorValue.object !== 'text') {
    throw new Error('Not a text node!');
  }

  const nodeInEditorValueParent = editorValue.document.getParent(nodeInEditorValue.key);
  let count = 0;
  let targetKey; // Note: do 'some' here so we can short circuit it when we reach our target
  // and don't have to loop through everything

  nodeInEditorValueParent.nodes.some(node => {
    if (node.object === 'text') {
      let text = '';
      node.leaves.forEach(leaf => {
        text += leaf.text;

        if (node === nodeInEditorValue && text.length > offset) {
          targetKey = `${block._key}${count}`;
          return;
        }

        count++;
      });
    } else {
      count++;
    }

    return node === nodeInEditorValue;
  });

  if (targetKey) {
    return [{
      _key: block._key
    }, 'children', {
      _key: targetKey
    }, 'text'];
  }

  throw new Error(`No target path found!`);
}

function createOperationToPatches(blockContentFeatures, blockContentType) {
  function toBlock(editorValue, index) {
    if (!editorValue.document.nodes.get(index)) {
      throw new Error(`No block found at index ${index} in value`);
    }

    return (0, _blockTools.editorValueToBlocks)({
      document: {
        nodes: [editorValue.document.nodes.get(index).toJSON(VALUE_TO_JSON_OPTS)]
      }
    }, blockContentType)[0];
  } // eslint-disable-next-line complexity


  function insertTextPatch(operation, beforeValue, afterValue, formBuilderValue) {
    const patches = []; // Make sure we have a document / start block first

    if (!formBuilderValue || formBuilderValue.length === 0) {
      // Value is undefined
      if (!formBuilderValue) {
        patches.push((0, _PatchEvent.setIfMissing)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType)));
      } // Value is empty


      if (formBuilderValue && formBuilderValue.length === 0) {
        patches.push((0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), []));
      }
    }

    const blockBefore = toBlock(beforeValue, operation.path.get(0));
    const blockAfter = toBlock(afterValue, operation.path.get(0));
    const nodeInEditorValue = afterValue.document.getNode(operation.path);
    const targetPath = findSpanTargetPath(nodeInEditorValue, operation.offset, afterValue, blockAfter);
    const targetKey = (0, _get2.default)(targetPath.slice(-2)[0], '_key');
    const span = blockAfter.children.find(child => child._key === targetKey);

    if (!span) {
      throw new Error(`Could not find span with key '${targetKey}' in block`);
    }

    const nodeInEditorValueBefore = beforeValue.document.getNode(operation.path); // If leaves have changed, and we are not on the end of the text,
    // set the whole block so we get the new block structure right

    if (nodeInEditorValue.leaves.size !== beforeValue.document.getNode(operation.path).leaves.size && operation.offset !== nodeInEditorValueBefore.text.length) {
      return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);
    } // The span doesn't exist from before, so do an insert patch


    if (blockBefore.children.some(child => child._key === targetKey) === false) {
      const spanIndex = blockAfter.children.findIndex(child => child._key === targetKey);
      const targetInsertPath = targetPath.slice(0, -2).concat({
        _key: blockAfter.children[spanIndex - 1]._key
      });
      return patches.concat((0, _PatchEvent.insert)([span], 'after', targetInsertPath));
    } // Check if marks have changed and set the whole span with new marks if so


    const point = {
      path: operation.path,
      offset: operation.offset + 1
    };
    const textMarks = beforeValue.document.getMarksAtRange(_slate.Range.fromJSON({
      anchor: point,
      focus: point
    })).map(m => m.type).toArray();

    if (!(0, _isEqual2.default)(textMarks, span.marks)) {
      return patches.concat((0, _PatchEvent.set)(span, targetPath.slice(0, -1)));
    } // Marks not changed, just set the text


    return patches.concat((0, _PatchEvent.set)(span.text, targetPath));
  }

  function setNodePatch(operation, beforeValue, afterValue, formBuilderValue) {
    const patches = [];
    const block = toBlock(afterValue, operation.path.get(0)); // Value is undefined

    if (!formBuilderValue) {
      patches.push((0, _PatchEvent.setIfMissing)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType)));
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      patches.push((0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), []));
    }

    if (formBuilderValue && formBuilderValue.length > 0) {
      patches.push((0, _PatchEvent.set)(block, [{
        _key: block._key
      }]));
    } // console.log(JSON.stringify(patches, null, 2))


    return patches;
  }

  function insertNodePatch(operation, beforeValue, afterValue, formBuilderValue) {
    // Value is undefined
    if (!formBuilderValue) {
      return [(0, _PatchEvent.setIfMissing)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType))];
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      return [(0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), [])];
    }

    const block = toBlock(afterValue, operation.path.get(0));

    if (operation.path.size === 1) {
      let position = 'after';
      let positionPath;

      if (operation.path.get(0) === 0) {
        const firstNode = beforeValue.document.nodes.first();
        positionPath = firstNode ? [{
          _key: firstNode.key
        }] : [0];
        position = 'before';
      } else {
        positionPath = [{
          _key: beforeValue.document.nodes.get(operation.path.get(0) - 1).key
        }];
      }

      return [(0, _PatchEvent.insert)([block], position, positionPath)];
    }

    return [(0, _PatchEvent.set)(block, [{
      _key: block._key
    }])];
  }

  function splitNodePatch(operation, afterValue) {
    const patches = [];
    const splitBlock = toBlock(afterValue, operation.path.get(0));

    if (operation.path.size === 1) {
      patches.push((0, _PatchEvent.set)(splitBlock, [{
        _key: splitBlock._key
      }]));
      const newBlock = toBlock(afterValue, operation.path.get(0) + 1);
      patches.push((0, _PatchEvent.insert)([newBlock], 'after', [{
        _key: splitBlock._key
      }]));
    }

    if (operation.path.size > 1) {
      patches.push((0, _PatchEvent.set)(splitBlock, [{
        _key: splitBlock._key
      }]));
    }

    return patches;
  }

  function mergeNodePatch(operation, afterValue) {
    const patches = [];

    if (operation.path.size === 1) {
      const mergedBlock = toBlock(afterValue, operation.path.get(0));
      const targetBlock = toBlock(afterValue, operation.path.get(0) - 1);
      patches.push((0, _PatchEvent.unset)([{
        _key: mergedBlock._key
      }]));
      patches.push((0, _PatchEvent.set)(targetBlock, [{
        _key: targetBlock._key
      }]));
    }

    if (operation.path.size > 1) {
      const mergedBlock = toBlock(afterValue, operation.path.get(0));
      patches.push((0, _PatchEvent.set)(mergedBlock, [{
        _key: mergedBlock._key
      }]));
    }

    return patches;
  }

  function moveNodePatch(operation, beforeValue, afterValue) {
    const patches = [];

    if (operation.path.size === 1) {
      if (operation.path.get(0) === operation.newPath.get(0)) {
        return [];
      }

      const block = toBlock(beforeValue, operation.path.get(0));
      patches.push((0, _PatchEvent.unset)([{
        _key: block._key
      }]));
      let position = 'after';
      let positionPath;

      if (operation.path.get(0) === 0) {
        const firstNode = beforeValue.document.nodes.first();
        positionPath = firstNode ? [{
          _key: firstNode.key
        }] : [0];
        position = 'before';
      } else {
        positionPath = [{
          _key: beforeValue.document.nodes.get(operation.path.get(0) - 1).key
        }];
      }

      patches.push((0, _PatchEvent.insert)(block, position, positionPath));
    } else {
      const changedBlockFrom = toBlock(afterValue, operation.path.get(0));
      const changedBlockTo = toBlock(afterValue, operation.newPath.get(0));
      patches.push((0, _PatchEvent.set)(changedBlockFrom, [{
        _key: changedBlockFrom._key
      }]));
      patches.push((0, _PatchEvent.set)(changedBlockTo, [{
        _key: changedBlockTo._key
      }]));
    }

    return patches;
  }

  function removeNodePatch(operation, beforeValue, afterValue) {
    const patches = [];
    const block = toBlock(beforeValue, operation.path.get(0));

    if (operation.path.size === 1) {
      patches.push((0, _PatchEvent.unset)([{
        _key: block._key
      }]));
    }

    if (operation.path.size > 1) {
      // Only relevant for 'block' type blocks
      if (block._type !== 'block') {
        return patches;
      }

      const changedBlock = toBlock(afterValue, operation.path.get(0));
      patches.push((0, _PatchEvent.set)(changedBlock, [{
        _key: changedBlock._key
      }]));
    }

    if (patches.length === 0) {
      throw new Error(`Don't know how to unset ${JSON.stringify(operation.toJSON(VALUE_TO_JSON_OPTS))}`);
    }

    return patches;
  } // eslint-disable-next-line complexity


  return function operationToPatches(operation, beforeValue, afterValue, formBuilderValue // This is optional, but needed for setting setIfMissing patches correctly
  ) {
    switch (operation.type) {
      case 'insert_text':
        return insertTextPatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_text':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'add_mark':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_mark':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'set_node':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'insert_node':
        return insertNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_node':
        return removeNodePatch(operation, beforeValue, afterValue);

      case 'split_node':
        return splitNodePatch(operation, afterValue);

      case 'merge_node':
        return mergeNodePatch(operation, beforeValue);

      case 'move_node':
        return moveNodePatch(operation, beforeValue, afterValue);

      default:
        return [];
    }
  };
}