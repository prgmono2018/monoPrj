/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
import classNames from "classnames";
import * as React from "react";
import { DISPLAYNAME_PREFIX, Keys, Popover, Position, TagInput, Utils, } from "@blueprintjs/core";
import { Classes } from "../../common";
import { QueryList } from "../query-list/queryList";
export class MultiSelect extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            isOpen: (this.props.popoverProps && this.props.popoverProps.isOpen) || false,
        };
        this.TypedQueryList = QueryList.ofType();
        this.refHandlers = {
            input: (ref) => {
                this.input = ref;
                const { tagInputProps = {} } = this.props;
                Utils.safeInvoke(tagInputProps.inputRef, ref);
            },
            queryList: (ref) => (this.queryList = ref),
        };
        this.renderQueryList = (listProps) => {
            const { tagInputProps = {}, popoverProps = {}, selectedItems = [], placeholder } = this.props;
            const { handleKeyDown, handleKeyUp } = listProps;
            return (React.createElement(Popover, Object.assign({ autoFocus: false, canEscapeKeyClose: true, enforceFocus: false, isOpen: this.state.isOpen, position: Position.BOTTOM_LEFT }, popoverProps, { className: classNames(listProps.className, popoverProps.className), onInteraction: this.handlePopoverInteraction, popoverClassName: classNames(Classes.MULTISELECT_POPOVER, popoverProps.popoverClassName), onOpened: this.handlePopoverOpened }),
                React.createElement("div", { onKeyDown: this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: this.state.isOpen ? handleKeyUp : undefined },
                    React.createElement(TagInput, Object.assign({ placeholder: placeholder }, tagInputProps, { className: classNames(Classes.MULTISELECT, tagInputProps.className), inputRef: this.refHandlers.input, inputValue: listProps.query, onInputChange: listProps.handleQueryChange, values: selectedItems.map(this.props.tagRenderer) }))),
                React.createElement("div", { onKeyDown: this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: handleKeyUp }, listProps.itemList)));
        };
        this.handleItemSelect = (item, evt) => {
            if (this.input != null) {
                this.input.focus();
            }
            Utils.safeInvoke(this.props.onItemSelect, item, evt);
        };
        this.handleQueryChange = (query, evt) => {
            this.setState({ isOpen: query.length > 0 || !this.props.openOnKeyDown });
            Utils.safeInvoke(this.props.onQueryChange, query, evt);
        };
        this.handlePopoverInteraction = (nextOpenState) => requestAnimationFrame(() => {
            // deferring to rAF to get properly updated activeElement
            const { popoverProps = {} } = this.props;
            if (this.input != null && this.input !== document.activeElement) {
                // the input is no longer focused so we can close the popover
                this.setState({ isOpen: false });
            }
            else if (!this.props.openOnKeyDown) {
                // open the popover when focusing the tag input
                this.setState({ isOpen: true });
            }
            Utils.safeInvoke(popoverProps.onInteraction, nextOpenState);
        });
        this.handlePopoverOpened = (node) => {
            const { popoverProps = {} } = this.props;
            if (this.queryList != null) {
                // scroll active item into view after popover transition completes and all dimensions are stable.
                this.queryList.scrollActiveItemIntoView();
            }
            Utils.safeInvoke(popoverProps.onOpened, node);
        };
        this.getTargetKeyDownHandler = (handleQueryListKeyDown) => {
            return (e) => {
                const { which } = e;
                if (which === Keys.ESCAPE || which === Keys.TAB) {
                    // By default the escape key will not trigger a blur on the
                    // input element. It must be done explicitly.
                    if (this.input != null) {
                        this.input.blur();
                    }
                    this.setState({ isOpen: false });
                }
                else if (!(which === Keys.BACKSPACE || which === Keys.ARROW_LEFT || which === Keys.ARROW_RIGHT)) {
                    this.setState({ isOpen: true });
                }
                if (this.state.isOpen) {
                    Utils.safeInvoke(handleQueryListKeyDown, e);
                }
            };
        };
    }
    static ofType() {
        return MultiSelect;
    }
    render() {
        // omit props specific to this component, spread the rest.
        const { openOnKeyDown, popoverProps, tagInputProps, ...restProps } = this.props;
        return (React.createElement(this.TypedQueryList, Object.assign({}, restProps, { onItemSelect: this.handleItemSelect, onQueryChange: this.handleQueryChange, ref: this.refHandlers.queryList, renderer: this.renderQueryList })));
    }
}
MultiSelect.displayName = `${DISPLAYNAME_PREFIX}.MultiSelect`;
MultiSelect.defaultProps = {
    placeholder: "Search...",
};
//# sourceMappingURL=multiSelect.js.map