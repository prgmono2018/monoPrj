/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
import * as React from "react";
import { DISPLAYNAME_PREFIX, Keys, Menu, Utils } from "@blueprintjs/core";
import { executeItemsEqual, renderFilteredItems, } from "../../common";
export class QueryList extends React.Component {
    constructor(props, context) {
        super(props, context);
        this.refHandlers = {
            itemsParent: (ref) => (this.itemsParentRef = ref),
        };
        /**
         * Flag indicating that we should check whether selected item is in viewport
         * after rendering, typically because of keyboard change. Set to `true` when
         * manipulating state in a way that may cause active item to scroll away.
         */
        this.shouldCheckActiveItemInViewport = false;
        /**
         * The item that we expect to be the next selected active item (based on click
         * or key interactions). When scrollToActiveItem = false, used to detect if
         * an unexpected external change to the active item has been made.
         */
        this.expectedNextActiveItem = null;
        /** default `itemListRenderer` implementation */
        this.renderItemList = (listProps) => {
            const { initialContent, noResults } = this.props;
            const menuContent = renderFilteredItems(listProps, noResults, initialContent);
            return React.createElement(Menu, { ulRef: listProps.itemsParentRef }, menuContent);
        };
        /** wrapper around `itemRenderer` to inject props */
        this.renderItem = (item, index) => {
            const { activeItem, query } = this.state;
            const matchesPredicate = this.state.filteredItems.indexOf(item) >= 0;
            const modifiers = {
                active: executeItemsEqual(this.props.itemsEqual, activeItem, item),
                disabled: isItemDisabled(item, index, this.props.itemDisabled),
                matchesPredicate,
            };
            return this.props.itemRenderer(item, {
                handleClick: e => this.handleItemSelect(item, e),
                index,
                modifiers,
                query,
            });
        };
        this.handleItemSelect = (item, event) => {
            this.setActiveItem(item);
            Utils.safeInvoke(this.props.onItemSelect, item, event);
            if (this.props.resetOnSelect) {
                this.setQuery("", true);
            }
        };
        this.handleKeyDown = (event) => {
            const { keyCode } = event;
            if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {
                event.preventDefault();
                const nextActiveItem = this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);
                if (nextActiveItem != null) {
                    this.setActiveItem(nextActiveItem);
                }
            }
            Utils.safeInvoke(this.props.onKeyDown, event);
        };
        this.handleKeyUp = (event) => {
            const { onKeyUp } = this.props;
            const { activeItem } = this.state;
            // using keyup for enter to play nice with Button's keyboard clicking.
            // if we were to process enter on keydown, then Button would click itself on keyup
            // and the popvoer would re-open out of our control :(.
            if (event.keyCode === Keys.ENTER && activeItem != null) {
                event.preventDefault();
                this.handleItemSelect(activeItem, event);
            }
            Utils.safeInvoke(onKeyUp, event);
        };
        this.handleQueryChange = (event) => {
            const query = event == null ? "" : event.target.value;
            this.setQuery(query);
            Utils.safeInvoke(this.props.onQueryChange, query, event);
        };
        const { query = "" } = this.props;
        const filteredItems = getFilteredItems(query, this.props);
        this.state = {
            activeItem: this.props.activeItem !== undefined
                ? this.props.activeItem
                : getFirstEnabledItem(filteredItems, this.props.itemDisabled),
            filteredItems,
            query,
        };
    }
    static ofType() {
        return QueryList;
    }
    render() {
        const { className, items, renderer, itemListRenderer = this.renderItemList } = this.props;
        return renderer({
            ...this.state,
            className,
            handleItemSelect: this.handleItemSelect,
            handleKeyDown: this.handleKeyDown,
            handleKeyUp: this.handleKeyUp,
            handleQueryChange: this.handleQueryChange,
            itemList: itemListRenderer({
                ...this.state,
                items,
                itemsParentRef: this.refHandlers.itemsParent,
                renderItem: this.renderItem,
            }),
        });
    }
    componentWillReceiveProps(nextProps) {
        if (nextProps.activeItem !== undefined) {
            this.shouldCheckActiveItemInViewport = true;
            this.setState({ activeItem: nextProps.activeItem });
        }
        if (nextProps.query != null) {
            this.setQuery(nextProps.query, nextProps.resetOnQuery, nextProps);
        }
    }
    componentDidUpdate(prevProps) {
        if (!Utils.shallowCompareKeys(this.props, prevProps, {
            include: ["items", "itemListPredicate", "itemPredicate"],
        })) {
            this.setQuery(this.state.query);
        }
        if (this.shouldCheckActiveItemInViewport) {
            // update scroll position immediately before repaint so DOM is accurate
            // (latest filteredItems) and to avoid flicker.
            requestAnimationFrame(() => this.scrollActiveItemIntoView());
            // reset the flag
            this.shouldCheckActiveItemInViewport = false;
        }
    }
    scrollActiveItemIntoView() {
        const scrollToActiveItem = this.props.scrollToActiveItem !== false;
        const externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, this.expectedNextActiveItem, this.props.activeItem);
        this.expectedNextActiveItem = null;
        if (!scrollToActiveItem && externalChangeToActiveItem) {
            return;
        }
        const activeElement = this.getActiveElement();
        if (this.itemsParentRef != null && activeElement != null) {
            const { offsetTop: activeTop, offsetHeight: activeHeight } = activeElement;
            const { offsetTop: parentOffsetTop, scrollTop: parentScrollTop, clientHeight: parentHeight, } = this.itemsParentRef;
            // compute padding on parent element to ensure we always leave space
            const { paddingTop, paddingBottom } = this.getItemsParentPadding();
            // compute the two edges of the active item for comparison, including parent padding
            const activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;
            const activeTopEdge = activeTop - paddingTop - parentOffsetTop;
            if (activeBottomEdge >= parentScrollTop + parentHeight) {
                // offscreen bottom: align bottom of item with bottom of viewport
                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;
            }
            else if (activeTopEdge <= parentScrollTop) {
                // offscreen top: align top of item with top of viewport
                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;
            }
        }
    }
    setQuery(query, resetActiveItem = this.props.resetOnQuery, props = this.props) {
        this.shouldCheckActiveItemInViewport = true;
        const hasQueryChanged = query !== this.state.query;
        if (hasQueryChanged) {
            Utils.safeInvoke(props.onQueryChange, query);
        }
        const filteredItems = getFilteredItems(query, props);
        this.setState({ filteredItems, query });
        // always reset active item if it's now filtered or disabled
        const activeIndex = this.getActiveIndex(filteredItems);
        const shouldUpdateActiveItem = resetActiveItem ||
            activeIndex < 0 ||
            // non-null assertion is safe because activeItem exists and was found in filteredItems
            // (guaranteed because activeIndex >=0 here)
            isItemDisabled(this.state.activeItem, activeIndex, props.itemDisabled);
        if (hasQueryChanged && shouldUpdateActiveItem) {
            this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));
        }
    }
    getActiveElement() {
        if (this.itemsParentRef != null) {
            return this.itemsParentRef.children.item(this.getActiveIndex());
        }
        return undefined;
    }
    getActiveIndex(items = this.state.filteredItems) {
        const { activeItem } = this.state;
        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.
        for (let i = 0; i < items.length; ++i) {
            if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {
                return i;
            }
        }
        return -1;
    }
    getItemsParentPadding() {
        // assert ref exists because it was checked before calling
        const { paddingTop, paddingBottom } = getComputedStyle(this.itemsParentRef);
        return {
            paddingBottom: pxToNumber(paddingBottom),
            paddingTop: pxToNumber(paddingTop),
        };
    }
    /**
     * Get the next enabled item, moving in the given direction from the start
     * index. A `null` return value means no suitable item was found.
     * @param direction amount to move in each iteration, typically +/-1
     */
    getNextActiveItem(direction, startIndex = this.getActiveIndex()) {
        return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);
    }
    setActiveItem(activeItem) {
        this.expectedNextActiveItem = activeItem;
        if (this.props.activeItem === undefined) {
            // indicate that the active item may need to be scrolled into view after update.
            this.shouldCheckActiveItemInViewport = true;
            this.setState({ activeItem });
        }
        Utils.safeInvoke(this.props.onActiveItemChange, activeItem);
    }
}
QueryList.displayName = `${DISPLAYNAME_PREFIX}.QueryList`;
QueryList.defaultProps = {
    resetOnQuery: true,
};
function pxToNumber(value) {
    return value == null ? 0 : parseInt(value.slice(0, -2), 10);
}
function getFilteredItems(query, { items, itemPredicate, itemListPredicate }) {
    if (Utils.isFunction(itemListPredicate)) {
        // note that implementations can reorder the items here
        return itemListPredicate(query, items);
    }
    else if (Utils.isFunction(itemPredicate)) {
        return items.filter((item, index) => itemPredicate(query, item, index));
    }
    return items;
}
/** Wrap number around min/max values: if it exceeds one bound, return the other. */
function wrapNumber(value, min, max) {
    if (value < min) {
        return max;
    }
    else if (value > max) {
        return min;
    }
    return value;
}
function isItemDisabled(item, index, itemDisabled) {
    if (itemDisabled == null || item == null) {
        return false;
    }
    else if (Utils.isFunction(itemDisabled)) {
        return itemDisabled(item, index);
    }
    return !!item[itemDisabled];
}
/**
 * Get the next enabled item, moving in the given direction from the start
 * index. A `null` return value means no suitable item was found.
 * @param items the list of items
 * @param isItemDisabled callback to determine if a given item is disabled
 * @param direction amount to move in each iteration, typically +/-1
 * @param startIndex which index to begin moving from
 */
export function getFirstEnabledItem(items, itemDisabled, direction = 1, startIndex = items.length - 1) {
    if (items.length === 0) {
        return null;
    }
    // remember where we started to prevent an infinite loop
    let index = startIndex;
    const maxIndex = items.length - 1;
    do {
        // find first non-disabled item
        index = wrapNumber(index + direction, 0, maxIndex);
        if (!isItemDisabled(items[index], index, itemDisabled)) {
            return items[index];
        }
    } while (index !== startIndex);
    return null;
}
//# sourceMappingURL=queryList.js.map